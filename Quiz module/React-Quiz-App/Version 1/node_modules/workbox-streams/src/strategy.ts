/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {logger} from 'workbox-core/_private/logger.js';
import {
  RouteHandlerCallback,
  RouteHandlerCallbackOptions,
} from 'workbox-core/types.js';
import {createHeaders} from './utils/createHeaders.js';
import {concatenateToResponse} from './concatenateToResponse.js';
import {isSupported} from './isSupported.js';
import {StreamSource} from './_types.js';
import './_version.js';

export interface StreamsHandlerCallback {
  ({url, request, event, params}: RouteHandlerCallbackOptions):
    | Promise<StreamSource>
    | StreamSource;
}

/**
 * A shortcut to create a strategy that could be dropped-in to Workbox's router.
 *
 * On browsers that do not support constructing new `ReadableStream`s, this
 * strategy will automatically wait for all the `sourceFunctions` to complete,
 * and create a final response that concatenates their values together.
 *
 * @param {Array<function({event, request, url, params})>} sourceFunctions
 * An array of functions similar to {@link workbox-routing~handlerCallback}
 * but that instead return a {@link workbox-streams.StreamSource} (or a
 * Promise which resolves to one).
 * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,
 * `'text/html'` will be used by default.
 * @return {workbox-routing~handlerCallback}
 * @memberof workbox-streams
 */
function strategy(
  sourceFunctions: StreamsHandlerCallback[],
  headersInit: HeadersInit,
): RouteHandlerCallback {
  return async ({event, request, url, params}: RouteHandlerCallbackOptions) => {
    const sourcePromises = sourceFunctions.map((fn) => {
      // Ensure the return value of the function is always a promise.
      return Promise.resolve(fn({event, request, url, params}));
    });

    if (isSupported()) {
      const {done, response} = concatenateToResponse(
        sourcePromises,
        headersInit,
      );

      if (